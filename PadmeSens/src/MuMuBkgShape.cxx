/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "MuMuBkgShape.h"
#include "RooAbsCategory.h"
#include "RooAbsReal.h"
#include "TMath.h"
#include <math.h>

using namespace std;

ClassImp(MuMuBkgShape);

MuMuBkgShape::MuMuBkgShape(const char *name, const char *title, RooAbsReal &_x,
                           const RooArgList &_coeffs, RooAbsReal &_xMin, RooAbsReal &_xMax)
    : RooAbsPdf(name, title), x("x", "x", this, _x),
      coeffs("coeffs", "coeffs", this), xMin("xMin", "xMin", this, _xMin), xMax("xMax", "xMax", this,_xMax) { //coeffs non ha una variabile _coef perché è una lista e viene letta tutta insieme
  for (int i = 0; i < _coeffs.getSize(); ++i) {
  RooAbsArg* coef = _coeffs.at(i);
  if (!static_cast<RooAbsReal *>(coef)) {
    cout << "MuMuBkgShape::ctor(" << GetName() << ") ERROR: coefficient "
              << coef->GetName() << " is not of type RooAbsReal "
              << endl;
    R__ASSERT(0);
  }
  coeffs.add(*coef);
}

}

MuMuBkgShape::MuMuBkgShape(const MuMuBkgShape &other, const char *name)
    : RooAbsPdf(other, name), x("x", this, other.x),
      coeffs("coeffs", this, other.coeffs), xMin("xMin", this, other.xMin),
      xMax("xMax", this, other.xMax) {}

Double_t MuMuBkgShape::evaluate() const { //nell'header è introdotta la funzione evaluate, qui viene definito come si calcola il valore della pdf in un punto
  if (x < xMin)
    return 0.;
  if (x > xMax)
    return 0.;

  int degree = coeffs.getSize() - 1;
  double xx = (x - xMin) / (xMax - xMin);
  double t = xx;
  double s = 1.0 - xx;

  double result = static_cast<RooAbsReal &>(coeffs[0]).getVal() * s;

  for (int i = 1; i < degree; i++) {
    result = (result + t * TMath::Binomial(degree, i) *
                           static_cast<RooAbsReal &>(coeffs[i]).getVal()) *
             s;
    t = t * xx;
  }

  result = result + t * static_cast<RooAbsReal &>(coeffs[degree]).getVal();
  return result;
}

Int_t MuMuBkgShape::getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char * /*rangeName*/) const { 
  if (matchArgs(allVars, analVars, x))
    return 1; // dice che se l'unica variabile di integrazione è la x, allora la pdf può essere integrata con la classe "analyticaIntegral" lo calcoliamo
  return 0;
}

double MuMuBkgShape::analyticalIntegral(Int_t code, const char *rangeName) const {
  R__ASSERT(code == 1);

  const double xlo = 0.;
  const double xhi = 1.;

  Int_t degree = coeffs.getSize() - 1; // n+1 polys of degree n
  double norm(0);

  double temp = 0;
  for (int i = 0; i <= degree; ++i) {
    // for each of the i Bernstein basis polynomials
    // represent it in the 'power basis' (the naive polynomial basis)
    // where the integral is straight forward.
    temp = 0;
    for (int j = i; j <= degree; ++j) { // power basis≈ß
      temp += pow(-1., j - i) * TMath::Binomial(degree, j) *
              TMath::Binomial(j, i) *
              (TMath::Power(xhi, j + 1) - TMath::Power(xlo, j + 1)) / (j + 1);
    }
    temp *= static_cast<RooAbsReal &>(coeffs[i]).getVal(); // include coeff
    norm += temp; // add this basis's contribution to total
  }

  norm *= xMax-xMin;
  return norm;
}
